\input{header.tex}

\usepackage{verbatim}
\begin{document}
\subtitle{}
\maketitle

\tableofcontents
\vfill
\pagebreak

\section{Słownik}

  \begin{itemize}
    \item \textbf{Klient eXtend} - część projektu eXtend przeznaczona do uruchamiania na klientach. Obejmuje skrypt w Pythonie wraz z niezbędnymi bibliotekami oraz aplikację klienta VNC,
    \item \textbf{Serwer eXtend} - część projektu eXtend uruchamiana na serwerze. Obejmuje skrypt w Pythonie, niezbędne biblioteki, aplikację serwera VNC (x11vnc) oraz sterownik xserver-xorg-video-intel,
    \item \textbf{Klient} - maszyna wykorzystywana przez serwer jako dodatkowy monitor rozszerzający dostępną powierzchnię pulpitu,
    \item \textbf{Serwer} - komputer zarządzający połączeniem z klientami i wysyłający im obraz do wyświetlenia.
  \end{itemize}

\section{Cel prac i wizja produktu}

  Problem, z którym zmagaliśmy się w ramach pracy inżynierskiej, to możliwość wykorzystania połączonych w sieć komputerów jako dodatkowych monitorów. Dodatkowym wymaganiem była możliwość uruchomienia projektu pod systemem Linux. Docelowo nasze rozwiązanie miało umożliwiać wyświetlenie pulpitu pojedynczego komputera na ekranie złożonym z 24 monitorów podłączonych do 4 niezależnych stacji roboczych dostępnym w Katedrze Informatyki AGH.

  \subsection{Istniejące rozwiązania o zbliżonej tematyce}

    \begin{itemize}

      \item \textbf{MaxiVista} \cite{ProjMaxiVista}

        Jest to projekt bliźniaczo podobny do naszego. Umożliwia podpięcie dodatkowych komputerów po sieci z użyciem TCP/IP. Nie satysfakcjonuje on nas ze względu na pewne poważne ograniczenia:
        \begin{itemize}
          \item na maszynie będącej serwerem musi być zainstalowany system Windows, klientem może być Windows lub Mac,
          \item można podłączyć maksymalnie 3 klienty,
          \item większość opcji jest dostępna tylko w wersji Pro,
          \item za darmo dostępna jest tylko 30-dniowa wersja próbna,
          \item ilość dostępnych rozdzielczości jest mocno ograniczona.
        \end{itemize}

      \item \textbf{ZoneScreen} \cite{ProjZoneScreen}

        Projekt analogiczny do MaxiVista, ale darmowy. Serwer działa tylko pod Windowsem, ale klientem może być dowolny system, na którym można uruchomić klienta VNC. Obsługuje więcej niż jednego klienta - autor nie podaje górnego ograniczenia.

      \item \textbf{AirDisplay} \cite{ProjAirDisplay}

        Podobny do MaxiVista i ZoneScreen. Można podłączyć maksymalnie 4 ekrany, chociaż informacja na stronie mówi, że działa to tylko na Macach. Klientami mogą być urządzenia z Androidem, Windowsem, OS X-em lub iOSem.

      \item \textbf{Xdmx} - Distributed Multihead X \cite{ProjXDMX}

        Open-sourcowy projekt oparty na hierarchii serwerów X - jeden ``główny'' (front-end) i wiele ``podrzędnych'' (back-end). Był to projekt, z którym początkowo wiązaliśmy największe nadzieje: w końcu był stworzony z myślą o linuksie i X11. Próby jego użycia jednak spełzły na niczym - okazało się, że projekt na Sourceforge nie jest aktualizowany od 10 lat i brakuje informacji o tym, że jego repozytorium zostało przeniesione na freedesktop.org/xorg. Brakuje aktualnej dokumentacji, aktualizacje pojawiają się niezwykle rzadko, a co gorsza sam projekt do obsługi wielu monitorów korzysta z rozszerzenia Xinerama, które zostało de facto zastąpione przez RandR. Mimo usilnych prób nie udało nam się doprowadzić Xdmx do działania.

      \item \textbf{ParaView} \cite{ProjParaView}

        ParaView jest obsługującą rozproszone wielomonitorowe konfiguracje aplikacją do wizualizacji danych w 3D. Jest to program używany w laboratorium w Katedrze Informatyki, ale niestety nie można użyć go jako narzędzia pozwalającego na transmisję fragmentu pulpitu.

    \end{itemize}

  \subsection{Studium wykonalności i analiza ryzyka}

    Już na etapie rozpoczęcia prac nad projektem wiedzieliśmy, że istnieją alternatywne rozwiązania, które jednak nie działają pod wymaganym systemem operacyjnym (Linux). Wiedzieliśmy zatem, że problem jest możliwy do rozwiązania, chociaż żaden z nas nie miał pojęcia, w jaki sposób powinniśmy to osiągnąć. Najwięcej wątpliwości co do wykonalności projektu brało się właśnie stąd, że pomimo istnienia analogicznych aplikacji pod inne systemy operacyjne nikt nie pokusił się o stworzenie wersji linuksowej. Pozwalało to domniemywać, że zagadnienie to może sprawiać więcej problemów, niż wydaje się na początku. Z tego powodu pierwsza iteracja została przez nas w całości poświęcona na zaznajomienie się ze sposobem działania podobnych rozwiązań oraz stworzenie minimalnego funkcjonalnego prototypu.

    Kolejnym istotnym czynnikiem, jaki musieliśmy wziąć pod uwagę, jest różnorodność sprzętu, na którym można uruchomić Linuksa. Sterowniki kart graficznych różnych producentów nie udostępniają takich samych możliwości. Przekonaliśmy się o tym już podczas tworzenia prototypu, który uświadomił nam, że będziemy w stanie osiągnąć nasz cel wyłącznie na kartach graficznych Intela.

    \vfill
    \pagebreak

\section{Zakres funkcjonalności}

  Aplikacja będąca wynikiem prac nad projektem miała:

  \begin{itemize}[noitemsep]
    \item umożliwić rozszerzenie pulpitu serwera o monitor klienta z użyciem sieci,
    \item działać pod systemem operacyjnym Linux,
    \item być w stanie obsłużyć 24-ro segmentowy monitor znajdujący się w laboratorium 1.18, obsługiwany przez 4 niezależne komputery,
    \item posiadać multiplatformową część kliencką, pozwalającą na wykorzystanie maszyn z różnymi systemami operacyjnymi,
    \item być prosta w instalacji i użytkowaniu,
    \item działać na tyle niezawodnie, na ile pozwala na to architektura sieciowa,
    \item działać wystarczająco wydajnie, by nie przeszkadzać w pracy z jej użyciem.
  \end{itemize}

\section{Wybrane aspekty realizacji}

  \subsection{Przyjęte założenia}

    Do prac nad projektem zdecydowaliśmy się użyć przede wszystkim Pythona, ze względu na popularność tego języka, szybkość implementowania oraz dostępność wielu bibliotek.

    Przygotowany prototyp aplikacji uświadomił nam, że dużo problemem dużo większym niż początkowo zakładaliśmy będą możliwości sterowników grafiki - aktualnie jedynie sterownik Intela jest w stanie tworzyć wirtualne ekrany, które są nam niezbędne. Modyfikacja innych sterowników w celu zaimplementowania tej funkcji okazała się przerastać nasze możliwości, więc ograniczyliśmy się do obsługi kart graficznych Intela.

    Do transmisji obrazu użyliśmy VNC, a konkretnie projektu x11vnc \cite{x11vncProj}. Dzięki skorzystaniu ze sprawdzonego protokołu zyskaliśmy pewność, że wydajność rozwiązania jest zadowalająca. Dodatkowym plusem okazało się to, że jest to projekt open-source, co dało nam możliwość odnalezienia i poprawienia napotkanego przez nas błędu (patrz: \ref{sec:x11vncBug}).

    \vfill
    \img{architecture.png}{Architektura aplikacji.}{Arch}

  \subsection{Architektura systemu}

    Prototyp systemu opiera się na sterowniku grafiki xserver-xorg-video-intel do kart graficznych Intela, który udostępnia rozszerzenie o nazwie intel-virtual-output. Pozwala ono na ``przekonanie'' serwera Xorg, że ma on do dyspozycji więcej fizycznych monitorów, niż w rzeczywistości jest do niego podłączonych. Obszary pulpitu nie mieszczące się na fizycznym monitorze maszyny są wysyłane do komputerów klienckich za pomocą protokołu VNC. Rozwiązanie to zakłada, że na komputerach klienckich są zainstalowane klienty VNC. Schemat architektury systemu jest przedstawiony na rysunku \ref{fig:Arch}.

    \fiximg{eXtend-app-overview.png}{Komunikacja klient-serwer.}{Comm}

    Projekt eXtend składa się z aplikacji serwerowej oraz klienckiej. Używają one dwóch niezależnych kanałów komunikacji, przedstawionych na rysunku \ref{fig:Comm}:
    \begin{itemize}
      \item połączenia konfiguracyjnego używającego TCP - w ten sposób klient i serwer negocjują parametry wirtualnego ekranu, identyfikator klienta oraz parametry połączenia VNC. Wiadomości są przesyłane z użyciem prostego tekstowego protokołu opracowanego przez nas,

      \item multicastowych pakietów UDP - serwer nadaje w ten sposób komunikaty o zmianie pozycji kursora w celu zminimalizowania zauważalnego opóźnienia między ruchem myszy a aktualizacją jego pozycji. Dodatkowo niepodłączone klienty po otrzymaniu tego typu pakietu traktują nadawcę jako serwer i próbują nawiązać połączenie konfiguracyjne po TCP. Ponieważ potrzebowaliśmy rozwiązania pozwalającego na minimalizację opóźnienia ruchów myszą względem aktualizacji pozycji kursora na ekranie, ilość pojawiających się w sieci pakietów ze współrzędnymi myszy mogła stać się całkiem spora. Użycie pakietów multicastowych pozwoliło nam uniezależnić szerokość pasma wykorzystywanego do transmisji pozycji kursora od ilości klientów podłączonych do serwera.
    \end{itemize}

    Dodatkowo po podłączeniu klienta nawiązywane jest kolejne połączenie (VNC) do transmisji obrazu, który ma zostać wyświetlony na kliencie.

  \subsection{Protokoły komunikacyjne}

    \subsubsection{Konfiguracja}

      W celu zapewnienia spójności przesyłanych danych używamy TCP jako protokołu warstwy transportowej. Dla uproszczenia implementacji nasz protokół opiera się na niezaszyfrowanych wiadomościach tekstowych: każda pojedyncza wiadomość kończy się znakiem nowej linii, pierwszy wyraz oznacza typ wiadomości, a kolejne - właściwe dane.

      Serwer może wysyłać następujące wiadomości:
      \begin{itemize}[nolistsep]
        \item \textbf{id} \emph{identyfikator} - informuje klienta, że został mu przydzielony podany \emph{identyfikator}, który powinien zostać wyświetlony na ekranie w celu jego identyfikacji,
        \item \textbf{vnc} \emph{host} \emph{port} \emph{offset\_x} \emph{offset\_y} - wysyła klientowi parametry przygotowanego dla niego połączenia VNC i informuje o położeniu ekranu klienta względem początku wirtualnego pulpitu. Ta wartość jest używana do poprawnego ustawiania kursora na ekranie klienta.
      \end{itemize}

      Klient wysyła do serwera tylko jeden typ wiadomości:
      \begin{itemize}[nolistsep]
        \item \textbf{resolution} \emph{szerokość} \emph{wysokość} - informuje serwer o dostępnej na kliencie rozdzielczości ekranu w pikselach.
      \end{itemize}

    \subsubsection{Komunikacja multicastowa}

      Do rozgłaszania adresu IP serwera oraz wysyłania aktualizacji pozycji kursora używamy 8-bajtowych datagramów UDP:
      \begin{itemize}[nolistsep]
        \item 4 bajty (32-bitowa liczba całkowita ze znakiem) - współrzędna X kursora,
        \item 4 bajty (32-bitowa liczba całkowita ze znakiem) - współrzędna Y kursora.
      \end{itemize}

    Kolejność wysyłanych w obie strony komunikatów przedstawia rysunek \ref{fig:ClientSeq}.
    \vfill

    \fiximg{eXtend-client-sequence.png}{Działanie aplikacji klienta}{ClientSeq}

\section{Organizacja pracy}

  \subsection{Podział prac}

    \textbf{Prace wykonane wspólnie}
    \begin{itemize}[noitemsep]
      \item analiza istniejących rozwiązań rozwiązujących podobny problem,
      \item opracowanie modelu komunikacji klient-serwer umożliwiającego automatyczną konfigurację serwera,
      \item opracowanie rozwiązania usprawniającego synchronizację ruchu kursora na ekranie klienta,
      \item dokumentacja projektu.
    \end{itemize}

    \noindent
    \textbf{Miłosz Łakomy}
    \begin{itemize}[noitemsep]
      \item opracowanie prototypowej wersji aplikacji,
      \item stworzenie skryptów upraszczających konfigurację wczesnej wersji projektu,
      \item zaprojektowanie i implementacja skryptu serwera.
    \end{itemize}

    \noindent
    \textbf{Marcin Radomski}
    \begin{itemize}[noitemsep]
      \item zlokalizowanie błędu w x11vnc i stworzenie łatki,
      \item zaprojektowanie i implementacja skryptu klienta,
      \item opracowanie prototypu klienta przeglądarkowego.
    \end{itemize}

  \subsection{Proces}

    Zastosowaliśmy iteracyjny model prac: w danym momencie nie skupialiśmy się na kompletnym rozwiązaniu całego projektu, ale wyznaczaliśmy sobie cel trochę przybliżający nas do ostatecznego produktu. Nie ustalaliśmy ścisłych terminów zakończenia iteracji, chociaż założyliśmy, że pojedyncza iteracja kończąca się funkcjonalnym prototypem nie powinna trwać dłużej niż 3-4 miesiące. Ponieważ repozytorium projektu znajduje się na Githubie, dla wygody użyliśmy mechanizmu ``issues'' do zarządzania zadaniami do wykonania.

    Aby zapewnić zgodność powstającego produktu z oczekiwaniami klienta, kontaktowaliśmy się z nim na bieżąco, prezentując mu nasze pomysły i aktualny stan prac nad projektem. Pozwoliło to na szybkie wyjaśnianie pojawiających się wątpliwości i jasne sprecyzowanie wymagań.

    \subsubsection{Iteracja 1}

      Pierwszą iterację poświęciliśmy w całości na dogłębne zapoznanie się z problemem, analizę sposobu działania alternatywnych aplikacji oraz stworzenie prototypu. Działał on dużo lepiej niż się tego spodziewaliśmy, więc w tym momencie zdecydowaliśmy się kontynuować prace nad tym rozwiązaniem. Efekt jaki uzyskaliśmy przedstawiają zdjęcia \ref{fig:It1Test1} oraz \ref{fig:It1Test2}.

      Największym problemem w tym momencie były regularnie pojawiające się czarne prostokąty, widoczne na zdjęciu \ref{fig:It1Test2}. Poza tym, szybkość odświeżania kursora myszy była niewystarczająca - dowiedzieliśmy się, że żeby aplikacja nie utrudniała pracy, potrzebujemy innego niż VNC mechanizmu aktualizacji jego pozycji.

      \img{it1_2.jpg}{[iteracja 1] główna część pulpitu widoczna na ekranie laptopa}{It1Test1}
      \img{it1_3.jpg}{[iteracja 1] kontynuacja pulpitu laptopa na górnej części 24-segmentowego ekranu}{It1Test2}

    \subsubsection{Iteracja 2}

      \label{sec:x11vncBug}
      Jednym z większych problemów, z którymi uporaliśmy się w ramach drugiej iteracji, było pozbycie się problemu czarnych prostokątów. Okazało się, że używany przez nas serwer x11vnc zaznacza obszary znajdujące się poza poprawnym obszarem pulpitu i pomija ich wysyłanie. Feralne prostokąty okazały się być wynikiem błędu w przeliczaniu koordynatów wspomnianych obszarów.

      Stworzyliśmy więc poprawkę \cite{x11vncPatch}, dołączyliśmy do niej opis problemu i wysłaliśmy pull request \cite{x11vncPullRequest} do autorów x11vnc. Po kilku dniach został on zaakceptowany, a łatka trafiła do głównej gałęzi repozytorium projektu. Efekt działania poprawki jest widoczny na zdjęciu \ref{fig:It2Test1}.

      \img{it2_1.jpg}{[iteracja 2] test załatanej wersji x11vnc}{It2Test1}

      Zaczęliśmy też pracować nad uproszczeniem konfiguracji, gdyż prototyp wymagał ręcznego uruchamiania aplikacji z terminala.

      Dodatkowo, zainteresowaliśmy się też projektem Guacamole \cite{Guacamole} - aplikacji pozwalającej użyć przeglądarki internetowej jako klienta VNC.

    \subsubsection{Iteracja 3}

      W tej iteracji zajęliśmy się stworzeniem skryptów umożliwiających proste podłączanie komputerów klienckich. Zaprojektowaliśmy system składający się z aplikacji klienckiej oraz serwerowej, umożliwiający automatyczne wykrywanie obecności serwera projektu w sieci oraz konfigurację połączenia z nim. Uprościło to konfigurację do tego stopnia, że użycie projektu sprowadziło się właściewie do uruchomienia skryptów klienta i serwera na odpowiednich maszynach.

    W trakcie tej iteracji powstał również prototyp modułu serwera umożliwiający podłączanie klientów przeglądarkowych z użyciem Guacamole. Został on zaprojektowany w taki sposób, aby mógł być używany równolegle z częścią obsługująca standardowe  klienty. Implementacja okazała się być jednak nietrywialna i powstały prototyp nie działał na tyle niezawodnie, żeby mógł stać się częścią projektu. Kolejnym z problemów było znaczne zwiększenie zależności aplikacji serwerowej. Po konsultacji z klientem i ustaleniu, że nie jest to niezbędna część aplikacji postanowiliśmy pozostawić ten moduł w fazie prototypu, nie dodając go do finalnej wersji aplikacji.

    \subsubsection{Iteracja 4}
      Czwartą, ostatnią iterację poświęcliśmy na doszlifowywanie naszej aplikacji oraz uzupełnianie dokumentacji projektu.

\section{Wyniki projektu}

  \subsection{Artefakty}

    W ramach projektu powstały dwa programy w Pythonie:

    \vspace{3mm}

    \textbf{Aplikacja kliencka:}
    \begin{itemize}[noitemsep,nolistsep]
      \item wykrywa ruch multicastowy pochodzący od serwera w celu jego zlokalizowania,
      \item łączy się z wykrytym serwerem,
      \item używa klienta VNC do wyświetlenia części pulpitu serwera.
    \end{itemize}

    \vspace{3mm}

    \textbf{Aplikacja serwerowa:}
    \begin{itemize}[noitemsep,nolistsep]
      \item rozgłasza swoją obecność w sieci komunikatami multicastowymi,
      \item przyjmuje połączenia klientów,
      \item przydziela każdemu klientowi część pulpitu, powiększając go w razie potrzeby,
      \item dla każdego klienta uruchamia serwer VNC wysyłający mu obraz z przydzielonej części pulpitu.
    \end{itemize}

    \vspace{3mm}

    Gotową aplikację przetestowaliśmy w laboratorium 1.18 Katedry Informatyki AGH, podłączając się do sieci zawierającej 4 komputery sterujące obrazem wyświetlanym na 24-monitorowym ekranie. Sprawdzaliśmy wydajność naszego rozwiązania, wyświetlając na ekranie przykładowy film. Działanie zaprezentowaliśmy również klientowi, który zgodnie z nami stwierdził, że efekt jest zadowalający.

  \subsection{Propozycje dalszych prac}

    Chociaż utworzony przez nas projekt jest w pełni działającym rozwiązaniem, w trakcie prac wpadliśmy na sporo pomysłów na jego dalsze usprawnienie:

    \begin{itemize}

      \item żeby projekt był naprawdę użyteczny, powinniśmy stworzyć paczki instalacyjne dla popularnych dystrybucji Linuksa, lub nawet opracować system automatycznie budujący je z repozytorium projektu,

      \item dużym krokiem w stronę zwiększenia wygody użytkowania projektu byłoby stworzenie graficznego interfejsu umożliwiającego ustawiania położenia ekranów klientów przez ich przeciągania. Byłoby to przydatne zwłaszcza w przypadku konfiguracji składających się z wielu klientów,

      \item kolejnym istotnym, lecz niestety nietrywialnym w implementacji usprawnieniem byłoby umożliwienie uruchamiania serwera na maszynach z kartami graficznymi innych popularnych producentów. Wymagałoby to jednak sporej ilości pracy nad upsrawienieniem ich sterowników,

      \item w przypadku ekranów o dużej powierzchni pożądane może być skalowanie obrazu w celu zwiększenia wydajności transmisji. Na wystarczająco dużych konfiguracjach zmniejszenie faktycznej rozdzielczości jest zauważalne dużo trudniej niż mała ilość wyświetlanych klatek na sekundę,

      \item interesującą możliwością jest wykorzystanie projektu Guacamole, co pozwoliłoby na zredukowanie zależności klienta do przeglądarki internetowej z obsługą HTML5 kosztem bardziej skomplikowanej architektury serwera. Podczas prac na projektem powstał co prawda prototyp tego rozwiązania, ale z powodu trudności technicznych oraz nietrywialnej konfiguracji wszystkich zależności tej wersji aplikacji zdecydowaliśmy się go porzucić.

    \end{itemize}

    \vfill

\pagebreak
\begin{thebibliography}{9}

  \bibitem{ProjMaxiVista}
    Strona projektu MaxiVista: \url{http://maxivista.com}

  \bibitem{ProjZoneScreen}
    Strona projektu ZoneSceen: \url{http://zoneos.com/zonescreen.htm}

  \bibitem{ProjAirDisplay}
    Strona projektu AirDisplay: \url{http://avatron.com/applications/air-display}

  \bibitem{ProjXDMX}
    Oryginalna strona projektu XDMX: \url{http://dmx.sourceforge.net} \\
    Aktualne repozytorium: \url{http://cgit.freedesktop.org/xorg/lib/libdmx/}

  \bibitem{ProjParaView}
    Strona projektu ParaView: \url{http://www.paraview.org/}

  \bibitem{x11vncProj}
    Repozytorium projektu x11vnc: \url{https://github.com/LibVNC/libvncserver}

  \bibitem{x11vncPatch}
    Łatka jest dostępna pod adresem \url{https://gist.github.com/dextero/bd2e22292a08417673e4} oraz na repozytorium projektu (plik \emph{x11vnc-blackout-clip-fix.patch}).

  \bibitem{x11vncPullRequest}
    Utworzona przez nas, wcielona do projektu x11vnc łatka: \url{https://github.com/LibVNC/libvncserver/pull/4}.

  \bibitem{Guacamole}
    Strona projektu Guacamole: \url{http://www.guac-dev.org}

\end{thebibliography}

\bibliography{Bibliografia}

\end{document}
